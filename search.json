[{"title":"重读经典：Word2Vec如何通过“简化”撬动了整个NLP世界？","url":"/2025/08/25/@mikolov2013EfficientEstimationWord/","content":"摘要: 2013年，一篇名为《Efficient Estimation of Word Representations in Vector Space》的论文横空出世，它提出的构成Word2Vec核心思想的CBOW和Skip-gram架构，彻底改变了我们让机器理解语言的方式。本文将带您重温这篇里程碑式的著作，探讨其核心思想：为何一个看似更“简单”的模型，反而能发现语言中令人惊叹的深层结构？\n原文链接：https://arxiv.org/abs/1301.3781\n注：为了无障碍理解这篇论文，阁下可能需要先理解文末 前置知识 中提到的一些基本概念。\n问题的根源：昂贵的“理解”在Word2Vec出现之前，自然语言处理（NLP）领域长期面临一个难题：如何让计算机理解词语之间的关系？传统方法如One-hot编码，将每个词视为一个独立的符号，这使得“国王”和“女王”在模型眼中毫无关联。\n\nas these(notion of words) are represented as indices in a vocabulary\n\n虽然当时先进的神经网络语言模型（NNLM）已经可以通过“分布式表示”（Distributed Representation）将词语学习为低维、稠密的向量（即词向量），并在一定程度上捕捉到语义相似性。但这些模型通常包含一个或多个复杂的非线性隐藏层。这个隐藏层是模型强大表达能力的核心，却也成为了巨大的计算瓶颈。其复杂度，特别是Hidden Layer的计算（N×D×H part），使得在数十亿词级别的海量数据集上训练模型变得不切实际。简单来说，当时的“理解”非常昂贵，以至于我们无法用足够多的数据去“喂养”它。\n\nThe main observation from the previous section was that most of the complexity is caused by the non-linear hidden layer in the model\n\n解决方案： 大道至简的两个模型面对上述瓶颈，Mikolov和他的同事们提出了一个颠覆性的思路：能不能用一个更简单的模型，来换取在更大规模数据上训练的能力？于是，他们大胆地移除了计算成本高昂的非线性隐藏层，从而极大地降低了计算复杂度。答案就是本文提出的两个核心架构：CBOW 和 Skip-gram。基本可以认为，这两个模型就是后来广为人知的Word2Vec。\n\n\nContinuous Bag-of-Words (CBOW)\n\n\n任务：根据上下文（周围的词）来预测中心词。\n做法：将目标词周围N个词的向量从投影矩阵(一个巨大的查询表，每一行即为一个词的向量)中取出，然后直接对它们进行求和平均，形成一个汇总的上下文向量，并用这个向量去预测中心词 。因为忽略了上下文的词序，所以被称为“词袋”（Bag-of-Words）模型。\n特点：多对一的预测，训练速度更快，对高频词效果更好。\n\n\nContinuous Skip-gram\n\n\n任务：与CBOW相反，它根据当前的中心词来预测其上下文。\n做法：将中心词的向量作为输入，去预测其前后一定范围（窗口C）内的多个上下文词语。并且通过将窗口的大小设计为固定范围的随机数，便可实现统计意义上的对远端词语进行更少采样，从而给予近处上下文更高的权重，这或许可以被看作是一种朴素的、非动态学习的“注意力”思想的雏形。\n特点：一对多的预测，训练时间更长，但能学习到更好的低频词表示，在大型语料上表现通常更优。论文的实验结果（如Table 3）也证实了这一点，Skip-gram在语义准确性上以55%对24%的巨大优势超过了CBOW。和CBOW不同，Skip-gram的训练模式可能会有些难以理解，容易产生歧义，具体讲解可见 Skip-gram训练机理\n\n这种简化带来的好处是惊人的。计算复杂度从NNLM的Q = N×D + N×D×H + H×V 急剧下降到CBOW的 Q = N×D + N×log_2(V) 和 Skip-gram的 Q = Cx(D + D×log_2(V))。正是这种效率上的巨大飞跃，使得在一天之内处理完16亿词的语料成为可能 ，也为接下来那个“魔法般”的发现奠定了基础。\n注：这里提到的Q基本上可以理解为模型一次预测所涉及的参数量; \n\nSimilar to [18], to compare different model architectures we define first the computational complexity of a model as the number of parameters that need to be accessed to fully train the model.\n\n注：此外，V到log_2(V)的变化是通过使用词汇的二叉树表示实现的，也就是说这对于NNLM的复杂度优化也是有用的，但是优化完之后，性能瓶颈在NxDxH, 仍然没有消失。\n\nWith binary tree representations of the vocabulary, the number of output units that need to be evaluated can go down to around log2(V ). Thus, most of the complexity is caused by the term N × D × H.\n\n惊人的发现：向量空间中的线性关系如果说高效的模型是这篇论文的“肌肉”，那么它揭示的向量线性关系就是其“灵魂”。论文最令人振奋的发现是，通过上述简单模型在海量数据上训练出的词向量，不仅仅是让“猫”和“狗”在空间中彼此靠近，更是捕捉到了词语之间丰富、可量化的类比关系（Analogy）。\n这种关系可以通过简单的向量代数运算来揭示。最经典的例子莫过于：这个等式石破天惊，它表明词向量空间中蕴含着抽象的语义维度，例如“性别”、“皇室”等。从“国王”的向量中减去“男人”的向量，相当于抽离出“男性”这个概念，保留了“皇室权威”等特征；再加上“女人”的向量，就将这个“皇室权威”的特征赋予了女性，最终得到的向量在空间中将接近“女王”对应的向量。在这个空间中，词向量的距离可以表示语义的相似度。\n为了系统性地验证这一发现，作者团队专门构建了一个包含语义(Semantic)和语法(Syntactic)类比问题的综合测试集Semantic-Syntactic Word Relationship test set。示例：\n\n语义类比: Athens is to Greece as Oslo is to? (Norway)\n语法类比: apparent is to apparently as rapid is to? (rapidly)\n\n注: 在实操上，可以通过上述向量运算得到结果向量，最后在整个词汇表的向量中，寻找与这个结果向量距离最近的词向量，这个词就是模型的答案——论文中使用的距离度量为“余弦距离”。在下以为，若所有词向量都预先进行归一化（使其长度为1），那么计算成本高昂的余弦距离就可以被简单的“向量点积”所替代。在单位球面上，按点积大小排序等同于按欧氏距离排序，但计算效率更高。ps: 单位球面上，\n实验结果（论文中的Table 3, 4; 6）雄辩地证明，CBOW和尤其是Skip-gram模型，在这类任务上的准确率远超当时更复杂的NNLM和RNNLM模型，同时训练成本大幅降低 。准确率：训练成本：\n历史回响：前沿性它被推翻了吗？\n思想从未被推翻，反而成为了基石。 “将词语映射到稠密向量空间中，通过无监督学习捕捉其语义”这一核心思想，已经成为整个现代NLP的奠基性观念之一。\n\n它还是最前沿吗？具体技术已演进，但思想永存。\n\nWord2Vec的局限在于它生成的是静态词向量(训练得到一个固定的词向量查询表)，对于一个token只有一个表示，无法处理一词多义问题（例如”bank”的“银行”和“河岸”两个含义共享同一个向量）。而当代的SOTA（State-of-the-Art）技术，如BERT、GPT等基于Transformer的模型，生成的是动态的、上下文相关的词向量。它们能根据句子语境为同一个词生成不同的表示，极大地提升了语义捕捉的精度。大体上应该可以理解成：输入句子之后，句子中的所有词首先经过一层类似于Word2Vec的初始嵌入，然后在经过注意力机制处理后，再输出每个词最终的词向量\n\n同时，CBOW由于其BOW的模型，缺乏对位置的建模； Skip-gram的位置概念也非常模糊，并未显式建模。\n\n此外，word2vec模型本身并未提供直接获取整个句子向量的有效方法，通常采用的“词向量平均”策略会丢失重要的语序和语法信息。\n\n然而，即便在今天，Word2Vec因其高效、轻量的特性，仍在学术研究和工业界中扮演着重要角色，甚至就连它被诟病的无法应对一词多义的问题有时也是一种优势——因为它可以得到一个稳定的向量训练结果，若要知晓某个词的向量，在向量表(投影矩阵)中直接查询即得。\n\n\n杂谈《Efficient Estimation of Word Representations in Vector Space》是一篇充满“反直觉”智慧的论文。它告诉我们，有时最优雅的解决方案并非来自更复杂的模型，而是来自对问题本质的深刻洞察。通过极致的简化，Word2Vec将计算力从复杂的模型结构中解放出来，投入到对海量数据的学习中，最终发现了语言本身蕴含的、令人着迷的数学之美。这不仅是一次技术的胜利，更是一次思想的胜利。\n一些可能容易迷惑的点：最终产物虽然Word2Vec在训练时的确利用了上下文，但请注意，训练的最终产物是一个固定的查询表（即投影矩阵 W）。训练结束后，无论“bank”出现在什么新的句子中，我们去使用它的词向量时，做的动作仅仅是查表——从矩阵W中把“bank”对应的那一行向量取出来。这个向量是一次性生成、全局固定的，所以它是“静态”的、“上下文无关”的。上下文信息在训练时被“蒸馏”进了这个固定的向量里，但在使用时，新的上下文不起作用。\n实际上这种方式训练出来的是一个既能进行嵌入又能进行预测的模型——正是因为有预测的能力，所以才能计算损失进行反向传播，从而不断调试投影矩阵，进而得到较好的词向量表示，也就得到了一个较好的嵌入模型。这或许也算是这类自监督学习（Self-supervised Learning）模型的训练哲学吧。我们并不真正关心模型预测得有多准，这个“预测任务”只是一个“借口”。我们真正的目标是，在完成这个任务的过程中，强迫模型学习到有意义的中间表示——也就是那个高质量的“投影矩阵”（词向量）\n共享投影层的说法论文在介绍模型架构时提到的共享投影层(using a shared projection matrix)可能会让人感到困惑。在下认为，这里的共享主要指的是对于上下文窗口的不同位置，使用是同一个投影矩阵进行映射；对比的是上下文窗口的每个位置分别维护不同的投影矩阵。除此之外，在CBOW中，作者还做了一个更激进的共享——投影后所处的空间位置也进行共享：输入的N个词向量在查找到之后，将被直接平均（Average）成一个单独的D维向量，空间位置信息被彻底抹除；对比在NNLM中，查到的向量会被拼接成N*D维的长向量\n\nNote that the weight matrix between the input and the projection layer is shared for all word positions in the same way as in the NNLM.\n\nSkip-gram训练机理要理解Skip-gram，首先需要明确其核心精髓——它不追求单个预测的精准度 预测任务只是一个“借口”，我们真正的目标是在这个过程中“锤炼”出优秀的词向量\nCBOW是将多个上下文单词加起来，然后用聚合后的向量一次性去预测中心词，每次训练就聚焦一次：目标词和使用聚合向量预测目标词的概率而Skip-gram, 则从中心词出发，和上下文窗口C中的所有词分别组成一个独立的训练样本对，每次训练就聚焦C次：这一次的目标词和使用中心词向量预测该目标词的概率例如：假设我们的句子是I am a fool, 窗口大小C=1, 当前处理的中心词是a则形成两个独立的训练样本对：\n\na -&gt; am\na -&gt; fool所以模型会训练两次，一次输入a，使用预测出am的概率计算损失；一次输入a，使用预测出fool的概率计算损失在使用层级Softmax的时候损失计算可能没有这么简单，但本质不变在反向传播的时候，不仅会调整输出层的权重，更重要的是也会调整a的词向量，从而不断拉扯a的词向量，让它更符合上下文语境\n\n计算复杂度论文中给出的计算复杂度公式乍一看可能有些吓人。但根据论文定义，它估算的主要是训练时需要访问的参数数量，理解起来并不复杂。下面我们进行简要拆解：\n\nNNLM: Q = N×D + N×D×H + H×V\n\n\nN×D：这部分代表从输入层到投影层的计算。将N个上下文单词（通常是one-hot）通过投影矩阵映射为N个D维向量，再拼接成一个N×D维的向量。因为涉及到了投影矩阵中的N行，所以对应参数量为N×D\nN×D×H：这是计算瓶颈，代表从投影层（N×D维）到非线性隐藏层（H维）的全连接计算。在这篇论文的语境下，应该是默认其所对比的NNLM为仅拥有单层非线性隐藏层的经典模型\nH×V：代表从隐藏层（H维）到巨大无比的输出层（V维，V是词汇表大小）的全连接计算。\n\n\nCBOW: Q = N×D + D×log₂(V)\n\n\nN×D：与NNLM类似，查询N个上下文单词的D维向量。\nD×log₂(V)：模型移除了N×D×H的隐藏层。将N个词向量平均后得到仅仅一个D维向量，直接用它来预测输出。同时，输出层使用层序Softmax（Hierarchical Softmax）这种技巧，将原本D×V的计算量降维打击至D×log₂(V)，因为它只需要在一个二叉树（深度约log₂(V)）上做一系列二分类判断，而不是在全部V个词上计算概率。所以这个技术对于NNLM同样适用，理论上上面NNLM的复杂度也可以优化，但是不影响CBOW和Skip-gram仍然远比它快。\n\n\nSkip-gram: Q = C×(D + D×log₂(V))\n\n\nD：输入只有一个词，查询其D维向量。\nD×log₂(V)：用这个D维输入向量，去预测一个上下文单词。与CBOW一样，也用了层序Softmax优化。\nC×(...)：因为Skip-gram模型需要对一个输入词，预测其周围的C个上下文单词，所以上述过程需要重复C次。\n\n一言以蔽之：Word2Vec的效率革命，主要来自（1）砍掉N×D×H的隐藏层 和（2）用log₂(V)复杂度的层序Softmax替换V复杂度的普通Softmax。\n关于层序Softmax的使用，感兴趣的话可以作者参考引用的这几篇论文\n\nT. Mikolov, A. Deoras, D. Povey, L. Burget, J. Cˇ ernocky ́. Strategies for Training Large Scale Neural Network Language Models, In: Proc. Automatic Speech Recognition and Understanding, 2011.\nA. Mnih, G. Hinton. A Scalable Hierarchical Distributed Language Model. Advances in Neural Information Processing Systems 21, MIT Press, 2009.\nF. Morin, Y. Bengio. Hierarchical Probabilistic Neural Network Language Model. AISTATS, 2005.\n\n前置知识\n词的表示方法：从One-hot到分布式表示\n\nOne-hot：想象一个词典有10万个词，那么“apple”这个词可能被表示成一个10万维的向量，其中只有对应“apple”的位置是1，其余全是0。这种方式无法体现词与词之间的关系 。\n分布式表示 (Distributed Representation)：与One-hot不同，它用一个稠密的、低维度的向量（例如300维）来表示一个词。向量中的每一个维度都代表了词语的某种潜在特征。这篇论文的核心就是如何高效地学习这种表示。\n\n\n全连接层\n\n一个全连接层包含一个权重矩阵W和一个偏置向量b。当输入一个向量x时，输出为y = Wx + b。\n\n\n神经网络语言模型 (NNLM) 的基本结构\n\n阁下只需要大致了解它通常包含输入层、投影层、隐藏层和输出层。\n其中投影层的概念可能会让人有点陌生，但对于理解本文思路又至关重要，所以这里在下简要介绍基本原理\n您可以把它想象成一个巨大的查询表。输入层的一个词就像一个开关，正好选中表中的某一行。这一行，就是一个低维、稠密的向量，它就是那个词的分布式表示。因此，这个投影层矩阵本身，在训练结束后，就成为了我们最终想要的“词向量词典”。\n\n\n\n\n向量空间与相似度\n\n当词语被表示为向量后，我们就可以在多维空间中计算它们之间的距离（如余弦距离）。距离越近，代表这两个词语的语义或用法越相似 。\n\n\n\nReferences[1] T. Mikolov, K. Chen, G. Corrado, and J. Dean. Efficient estimation of word representations in vector space. arXiv preprint arXiv:1301.3781, 2013.\n","categories":["AI","basis"],"tags":["AI","basis","Word2Vec","paper","impressive","NLP"]},{"title":"使用Git进行代码管理的经验谈","url":"/2025/08/30/Git-experience/","content":"这篇文章主要记录一些Git工具的使用方式，因为Git提供了很强大的功能，但是大部分功能在大多数情况下都不会用到，故在此简要记录方便未来作为速查表使用(使用ctrl+F可在浏览器快速查找关键词)。除此之外也记录一些在基于Git的开源社区如GitHub上观察到的一些社区规范或者说暗语, 在进行项目代码管理或参与开源贡献的时候可以作为参考。本文属于是不完全的梳理，所谓”经验谈”的意思其实就是当咱遇到了再进行相关的整理啦XD会持续更新的orz如有不恰当的地方或者想要补充的，欢迎在评论区交流 (^_−)☆\n使用Git拉取和推送最常见的自然是git pull和git fetch，但是个人更喜欢先fetch, 再merge。因为事实上，git pull其实是一个组合件，它会先调用git fetch, 然后再根据情况选择调用git rebase或者git merge[4][5] (或许大多数时候，它调用的是merge，基本可以认为它会调用merge，但只要咱把它拆开来用，把一切的掌控权拿在自己手中，不就不用纠结这个问题了喵(￣▽￣)~*)\n推荐流程:\n\ngit fetch &lt;远程仓库别名&gt; &lt;分支名&gt; 拉取远程仓库的指定分支的最新内容到本地，但不会直接合并, 先看看都发生了什么新的更改, 让自己拥有充分决策权\ngit merge &lt;远程仓库别名&gt;/&lt;分支名&gt; 将您看中的分支合并到当前分支，若出现冲突，则需要解决冲突，并提交\ngit push &lt;远程仓库别名&gt; &lt;分支名&gt; 将本地指定的分支上传到远端并和同名分支进行合并\n\n\n客观地说，最后一个部分可以改为&lt;本地分支名&gt;:&lt;远程分支名&gt;, 从而和指定分支进行合并，但是这真的有必要吗？中肯地说，在每次push之前，都应该先fetch远端所有必要的更改并在本地merge解决冲突之后，再进行push，所以最终分支名大抵是相同的。\n\n\n管理远程仓库git remote系命令可用于管理与当前仓库链接的远程仓库，具体用法如下：\n$ git remote add &lt;别名&gt; &lt;仓库URL&gt;\n该命令可以添加一个远程仓库，其中’仓库URL’替换为目标仓库的URL，即xxx.git, ‘别名’替换为任意名称，如’origin’/‘upstream’eg: git remote add upstream https://github.com/ElysiaFollower/ElysiaFollower.github.io.git在下认为这是这个分支最重要的一个命令\n至于添加远程仓库以后？那就基本可以完全抛却负担，像正常使用git一样进行使用啦。因为当我们平时git clone一个仓库的时候，实际上只是git clone自动帮我们添加了一个远程仓库, 本质是一样的[2]。关于这个问题，其实下面这条命令正好可以进行一定程度的佐证:git remote -v可以查看当前仓库的远程仓库举个例子:\n(base) PS D:\\myblog\\blog_in_develop\\themes\\redefine&gt; git remote -vorigin  https://github.com/ElysiaFollower/hexo-theme-redefine.git (fetch)origin  https://github.com/ElysiaFollower/hexo-theme-redefine.git (push)upstream        https://github.com/EvanNotFound/hexo-theme-redefine.git (fetch)upstream        https://github.com/EvanNotFound/hexo-theme-redefine.git (push)\n这是在下fork的一个仓库，这里的origin仓库就是git clone时自动产生的，而upstream仓库则是在下手动添加的。可以看到，在git remote -v眼里，他俩是同一回事。理解到此为止，所以添加之后只需要像正常一样使用git push和git fetch进行代码管理即可。不过需要注意的是，git fetch命令的’完整版’其实应该是[2][3] :git fetch &lt;远程仓库别名&gt; &lt;分支名&gt;只是git clone的时候，同时生成了一些缺省时的默认配置，但是在管理多个远程仓库的时候还是全部显式声明更加所见即所得。\n\nWhen git fetch is run without specifying what branches and/or tags to fetch on the command line, e.g. git fetch origin or git fetch, remote..fetch values are used as the refspecs—​they specify which refs to fetch and which local refs to update[3].\n\nfetch如此，push也是同理的:git push &lt;remote别名&gt; &lt;branch&gt;\n查看远程仓库相关信息:git remote show &lt;remote别名&gt;\n删除远程仓库：git remote remove &lt;remote别名&gt;\n社区暗语从Fork到Pull Request(PR)不知道大家是否会经常听到PR这个词呀，在下第一次听到这个词的时候，还以为是peer review的缩写(死去的fds和ads课程回忆突然开始攻击我), 但是代入上下文语境总觉得有些违和。后来了解之后才知道在开源共享或者项目管理中，PR往往指的实际上是Pull Request，即拉取请求 —— 您向原项目/仓库的维护者提交请求，建议他们合并你所做的修改在我的观察中，PR实际上可以理解为: 存在一个仓库A，而我们的手里有一个仓库B，这是基于A的延伸，或者基于A的修改，我们在仓库B的git历史中存在某一个分支，就像正常分支合并一样，我们可以通过Pull Request将这个分支合并/merge到仓库A的指定分支上中。 \nPR的好处都有啥PR的意义尤其在于开源贡献。请设想这样一个场景: 阁下在网上冲浪的时候发现了一份写得很好的代码，或者自己在使用某个开源工具的过程中体验到了一些难处，作者一直没有解决这个问题于是你决定自己动手。但是当您兴致满满地git clone完原仓库，幸苦完成了修改之后，自信满满地键入git push origin xxx-new-feature，您发现这个操作失败了，然后您意识到——您根本没有这个仓库的提交权限！若阁下尝试去直接联系仓库的维护者，且不说对方是否能够及时回复，就算回复了，对方可能也会出于不想有人把代码搞得一团糟甚至删库跑路等顾忌而不愿轻易提供写权限。那么难道这就死局了吗？非也非也，聪明的程序员们发明了PR机制来解决这个问题。它有以下几个特点(根据在GitHub上的观察):\n\n即便是对仓库没有写权限的人也可以发起PR\n当阁下发起PR的时候，阁下可以为您的修改写一份声色俱茂的小作文，包括目的、动机、实现方法、效果和测试结果等\n仓库的维护者可以直接查看您的修改(diff形式)，如果认为合适就可以合并到原仓库中，完成合并则等效于真的在原仓库中开了这么一条分支，在开发后合并到特定分支\nPR拥有评论区，您可以和仓库的维护者或者其他人在这里展开充满激情的辩论。如果您认为他人说的有道理，您可以回到自己的分支中修改代码(GitHub的PR会自动更新最新提交内容-2025/8/19)，然后您就会惊奇发现，当时那条PR的commit记录自动延长了，阁下可以马上附上更新说明，在一个连续的历史上下文中完善您的这一次贡献\n\n考虑到PR拥有的这些强大的能力——特别是“小作文”和评论区的设计——实际上为代码审查提供了很大的方便。所以在下肤浅的认为，对于一些大型项目的大型改动来说，即便是对于拥有写权限的开发者来说，学习使用PR也是非常有意义的！虽然网上能搜到的一些协作开发的范式大都是不同人负责不同的分支，开发完了合并。或许这对于较为小型的项目来说更为方便，但是试想那位进行merge的人需要承担多大的心里负担呐。擅自将自己开发完的分支合并到别人的分支或者main分支上，说不定过段时间就会有一位悲惨的程序员发现自己原来能跑的代码跑不了了，于是悄悄地破防了(；´д｀)ゞ。如果联系项目负责人，让Ta进行审查合并，且不说联系过程怪麻烦的，而且整个审查并不是公开透明的，未来出现了问题也增加了维护的难度。看，这些问题通过PR机制都能得到很好的解决ヽ(￣▽￣)ﾉ\nFork实乃何物PR这么有用，那么怎么PR呢。这时候就不得不提Fork了。在下以为Fork+PR的组合拳，已经是进行PR的一种社区规范了。\nFork实际上就是将一个仓库复制到自己的账号下，形成一个复制仓库，这样您就有了这个项目的副本，可以随意进行修改，而不会影响到主项目。\n\n也就是说，除了要发起PR的分支，阁下甚至可以开几条属于自己的草稿分支，并且不用担心遭到同伴亲切的问候“ 您在做神魔(O_o)?? ”\n\n至于怎么发起PR，则只需要在GitHub web端进入Fork形成的仓库副本，在Pull Request栏发起PR请求即可。事实上于在下的印象之中，当已经commit了几条之后，Fork的仓库首页就会贴心地提示您”Compare &amp; pull request”[1]\n小技巧在Fork的仓库中，阁下可以通过git remote add upstream &lt;原仓库URL&gt;来添加一个上游仓库(对应的git操作请参考)，这样您就可以通过git fetch upstream来将原仓库的最新代码拉取到自己的仓库中并通过git merge upstream/branch_name合并了！(￣▽￣)~*这样的话，就算是团队内部进行开发或者修改自己使用中的工具，使用Fork仓库也完全无负担，反而更方便，自由度更高\n\n不仅可以无缝追踪原仓库进度\n还有自己的草稿区\n\n注: 一般使用upstream作为原仓库的别名\n\nCommit Message规范网上很有多关于commits规范的说法，有的显得很复杂。在下以为，重要的还是能不能把事情说清楚(看到阿里在文章中说”建议使用中文（感觉中国人用中文描述问题能更清楚一些）”, 笑罢觉得还是有些事情值得反思的，形式主义没有意义)，所以这里摘些个人最认可也认为是最重要的部分充当一下互联网的记忆叭(￣^￣) [6][7]\n最值得参考的大抵还是Angular规范[8]和后来在它的基础上发展出来的Conventional Commits叭[6]Angular范式：\n&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt;\n作用域scope，body和footer都是可选的；前面几个都挺有用的，相对而言footer的可有可无性略高\n然后类型这边在下稍微糅合了一下，但都是接受度比较高的类型:\n\nfeat: 新功能\nfix: 修复bug\ndocs: 文档\nstyle: 样式修改 —— 主要是代码样式修改，不影响运行的那种[6]\nrefactor: 重构，代码重构，逻辑重构\ntest: 测试, 例如添加、删除、修改代码的测试用例等。\nchore: 用于对非业务性代码进行修改，例如修改构建流程或者工具配置等\nbuild: 用于修改项目构建系统，例如修改依赖库、外部接口或者升级 Node 版本等\nci: 用于修改持续集成流程，例如修改 Travis、Jenkins 等工作流配置；\nperf: 用于优化性能，例如提升代码的性能、减少内存占用等；\nrevert: 用于回滚版本\n\nfooter里面的’BREAKING CHANGE‘是什么？—— 简单来说就是不兼容修改, 本次提交修改后将不兼容之前版本的API或者环境变量。建议写上Before和After，分别表示修改前的和修改后的版本。\n关于怎么写，学理论不如看几个例子感受一下(。-`ω´-) ;取自[8] :\nReferences\nCoding Is Fun. 开源贡献：从 Fork 到 Pull Request（PR）. CSDN, 2024 ↩Git. 2.5 Git 基础 - 远程仓库的使用. git-scm, ↩Git. git-fetch - Download objects and refs from another repository. git-scm, 2025 ↩Runner_Jack. git fetch &amp; pull详解. 博客园, 2018 ↩Git. git-pull - Fetch from and integrate with another repository or a local branch. git-scm, 2025 ↩. convertionalcommits. , ↩阿里云开发者​. 如何规范你的Git Commit?. 知乎, 2025 ↩angular. AngularJS Git Commit Message Conventions document. github, ↩","categories":["Tools","code"],"tags":["Git","manual","code management"]},{"title":"为什么长方体上的三个点不能唯一确定一个长方体?","url":"/2025/09/16/MinimalRepresentingOfcuboid/","content":"本文是随手写的证明，仅抛砖引玉。在下虽已简单审阅思考了几遍觉得大致无误，但仍然不敢保证不存在证明或者说理上的失误，请阁下带着审慎的目光阅读。如有疑问请留言。\n确定一个三维空间中的任意长方体至少需要多少参数？一个三维空间中的任意长方体有9个自由度\n\n3个用于平移\n3个用于旋转\n3个用于长宽高(缩放)\n\n所以表示这样一个长方体至少需要9个数值\n如何用9个参数唯一确定一个长方体通俗法先使用6个数值，表示长方体的两个顶点，定义这两个顶点的连线构成长方体的高。\n则长方体的物理约束让我们知道”长方体顶面和底面所在的平面”\n\n以关注底面为例，我们只需要在底面定义一个全新的基(这个基可以来自于原来三维空间基的一种人为定义的映射，所以唯一确定)，然后使用一个二维向量表示出其中一条边的方向和长度，最后补上一个参数表示与它垂直的另一条边的长度。\n分别需要使用2个参数和1个参数。\n\n于是我们使用9个数值就得到了如图所示的长方体的4个顶点，而后使用常规方法即可得到长方体。\n如果您觉得这种方法看着不严谨，可以看看下面的数学法。\n数学法设\n\n表示长方体几何中心的位置\n\n 表示其沿自身三个主轴的长度，即长宽高\n\n 表示这个长方体的欧拉角，即朝向。在这里使用Z-Y-X顺序，表示长方体从一个自身主轴与坐标轴对齐的状态，先绕自身Z轴旋转，再绕自身Y轴旋转，最后绕自身X轴旋转\n\n\n充分性(重建过程):\n先在原点处创建标准长方体，尺寸为，并且长宽高分别与X、Y、Z轴平行。\n即, 其八个顶点坐标为：则我们有了一个几何中心位于原点的长方体，这长方体的形状和目标长方体完全一致。\n然后根据​对长方体进行旋转即可(左乘旋转矩阵)\n\n绕Z轴旋转 ​ (只需要计算坐标基旋转后的状态):  \n\n\n\n\n绕Y轴旋转:\n\n\n\n\n绕X轴旋转:\n\n\n\n\n\n对于之前得到的分别依次左乘上述旋转矩阵，就能得到几何中心在原点，但朝向完全正确的长方体。之后只需要对每个顶点坐标加上几何中心的坐标完成平移，即可重建长方体。\n为什么不能用三个在长方体上的点来重建一个长方体ps: 如果三个点不是在长方体上的点，与长方体无直接的几何关系，那和直接存储数值又有何异？私以为没有讨论价值，这里只讨论三个点在长方体上的情况。\n核心原因：三个在长方体上的点存在内生约束，它虽然有9个数值，但自由度并非9，有损失，无法表示需要9个自由量表示的长方体。\n只需要证明三个点的坐标数值至少存在一个自由度损失：\n若三个点均为长方体顶点首先我们可以在长方体上建立它自己的内生坐标系，方便讨论。\n情况1：存在两个顶点的连线构成了长方体的一条边AB\n根据对称性可知，第三个点实际上只有P1和P2两种情况。\n因为AB垂直于P1P2B平面，所以当AB已经确定的时候，P1与P2的x坐标是冗余的！这意味着至少存在一个自由度损失，相当于至多也就只有8个有用的数值，所以无法表示有9个自由度的长方体。\n情况2：存在两个顶点的连线构成了长方体的一条面对角线AB\n由对称性可知，第三个点实际上只有P1P2P3三种情况，并且P1和P3的情况直接退化到了前面讨论过的情况1：存在两个顶点的连线构成了长方体的一条边AB， 所以实际上只需要考虑P2。\n如果第三个顶点取P2的话，则ABP2包夹的顶点(对应图中P3位置)可能出现在平面ABP2的两侧，无法唯一确定。\n\n但是抛砖引玉：分别以AB，AP2，BP2为直径做球，交点即为解，但根据对称点，有两个交点\n然而即便如此，在工程上只需要人为定义稳定地取其中某一侧的解，则仍然可以构成一一映射关系——每个三点组可以映射到一个长方体，而每个长方体也唯一映射到一个三点组(一个长方体可以切出两个如图所示的面，但是在规定“只有位于平面的才算解”时，只有一个面是有效的)。但是那是另话了(实现起来可能会很麻烦)。不过，在数学上不能唯一确定但在工程上能够形成一一对应关系，确实会令人觉得很神奇。或许也有一些取巧的成分在里面吧\n\n\n\n情况3：存在两个顶点的连线构成了长方体的一条体对角线AB\n由对称性可知，实际上第三个点只有P1一种情况，而这种情况AP1构成了边，又退化到了情况1：存在两个顶点的连线构成了长方体的一条边AB，故而无法重建。\n若三个点中至少有一个点不是长方体的顶点核心思想：若点不是顶点，反而携带的信息量更少了，故而更不能重建了。\nps: 该部分或有不严谨的地方，请理性审阅\n情况1：有一个点在边上(不含顶点)重建长方体的目标可以建模成求解图中P, L1, L2, L3， 这都是最后重建长方体需要且必须能够解得的变量。\n\n\n所以我们用这几个基础性的变量来表征每个点为我们带来的信息。\n若得到的点是顶点，例如A，得到的方程实际上为:\n\nA = P + L1\n\n但若得到的点是边上的点，例如PA上的点T，则得到的方程实际上为：\n\nT = P + t  L1\n\n其中t是全新的未知的变量，实际上并不会增加整个方程组的确定性，反而会引来更多的未知数。\n情况2: 有一个点在面上(不含顶点)延续情况1的逻辑，若得到的点是面上的点，例如PAB上的点T，则得到的方程实际上为：\n\nT = P + u  L1 + v  L2\n\n其中u, v都是全新的未知的变量，实际上也并不会为整个方程组带来更多的信息。\n综上所述，仅仅使用长方体上的三个点重建(唯一确定)长方体是在数学上不可行的。工程上引入新的规则那咱不管\n","categories":["CS","ComputerGraphics"],"tags":["ComputerGraphics","Math","LinearAlgebra"]},{"title":"解决Windows端口被系统随机保留: `netstat`显示端口空闲，但是无法使用端口","url":"/2025/09/14/Windows%E7%AB%AF%E5%8F%A3%E8%A2%AB%E9%9A%8F%E6%9C%BA%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/","content":"最后更新于2025/9/14\n\nWindows 11 专业版\n\n碎碎念跳过碎碎念\n在大约一年之前，17号的室友曾遇到过一个clash代理无法生效的问题。17号尝试了很多手段，都没定位到问题的原因，但最后却是通过更换代理端口意外地解决了这个问题。当时推测是对应端口被占用，但是不明所以，于是不了了之。\n在前段时间17号在进行web开发的时候，又遇到了相似的问题，即端口被占用，无法使用。然而即便17号使用netstat -ano命令查看系统上所有的网络连接和端口状态，也没有发现绑定对应端口的进程。通过搜索，17号发现这个问题可能是因为Window系统会为Hyper-V服务保留一些端口，导致用户无法使用这些端口。虽然很无语，但是毕竟虚拟化服务还用得到，所以也没有去尝试从根本上解决这个问题。\n直到现在…昨天在为一个项目录制demo视频的时候，发现8000端口被占用，无法使用，导致demo录制到一半被迫中断，还被迫修改默认配置。而今天更是直接将17号clash代理http的端口，同时也是git的代理端口给封印了，害得17号连push和fetch都做不了！！！忍无可忍无需再忍，今天在下稍微深入一点地研究了这个问题，结果发现，这个问题有一半可以说是系统bug！它完全可以无痛解决而且很好解决！\n解决之后顺便写篇文章分享一下叭~如果哪里写得不恰当的，还请不吝赐教o(╥﹏╥)o\n现象netstat -ano | findstr 'port' (命令中的port替换为真实要查找的端口) 无输出。结果显示没有任何进程绑定了此端口，然而，任何试图使用该端口的尝试均以失败告终。\n无法使用的端口非常随机，让人无迹可寻。比如几天前可能可以使用某端口，但过两天可能突然不能用了。而且重启电脑还有概率解决这个问题。\n原因Windows有一个“TCP动态端口范围”，这个范围内的端口有时候可能会被系统随机占用。例如Hyper-V虚拟化服务，因为虚拟机也是需要支持网络服务的，故而虚拟机会需要真实的网络端口。所以Windows系统会为它预先保留一些端口以确保虚拟机能够正常使用。\n动态端口是指那些不固定分配给特定服务，而由系统动态分配给需要网络通信的应用程序的端口。\n在 Windows Vista（或 Windows Server 2008）之前，动态端口范围是 1025 到 5000；在 Windows Vista（或 Windows Server 2008）之后，新的默认起始端口为 49152，新的默认结束端口为 65535。[1][2]\n注意到新的默认起始端口为49152，这非常大，基本上不会保留我们平时常用的那些端口。但是！Windows的自动更新有时会出错，导致这个范围的起始端口被重置为1024，就有可能导致我们常用的8000等端口被占用。\n诊断方式netsh int ipv4 show dynamicport tcp该命令可以查看当前Windows计算机的TCP动态端口范围\n\n输出eg: \nProtocol tcp Dynamic Port Range-——————————–Start Port      : 49152Number of Ports : 16384\n\n如果阁下发现您的Start Port是1024或者一个相对较小的数字，那么阁下遇到的端口无法使用问题很可能就源自于此，建议手动恢复到正常的配置。\nnetsh int ipv4 show excludedportrange protocol=tcp该命令可以更直接地输出，当前被系统保留的端口范围。如果前面那个命令只是确诊了“风险”，那么这个命令就是实锤“病症”了，因为这里显示就是当前确确实实被系统保留而无法使用的端口范围了。如果阁下现在想要使用的端口就在里面，那么几乎可以肯定，端口无法使用的症结就在这了。\n\n输出eg:\nProtocol tcp Port Exclusion Ranges\nStart Port    End Port\n\n 50000       50059     \\*\n\n* - Administered port exclusions.\n\n解决方法以下命令要以管理员身份运行\nnetsh int ipv4 set dynamicport tcp start=49152 num=16384该命令可以重置ipv4的TCP动态端口范围。数值即为后来更新的正确的默认值49152-65535.\nnetsh int ipv6 set dynamicport tcp start=49152 num=16384该命令和上条相同，只不过修改的是ipv6不是ipv4，建议一起执行。\n执行完上述命令之后只需要重启电脑即可。不过实测发现，实际上只需要重启winnat即可, 即：net stop winnatnet start winnat\n\n注：winnat是Windows网络地址转换服务，重启它可以强制系统重新评估网络配置并释放被错误保留的端口[4]\n\n不放心的话可以再使用上一节“诊断方式”中给出的两种方法重新进行一次诊断。如果阁下要使用的端口已不在保留的端口范围中，则这方面的问题就已经解决啦~ (注: 若此时形如clash代理的服务仍无法使用，则大概率只需要重启clash就可以解决, 不重启或许它不会主动尝试再申请对应端口)\n参考文献\n爱丽丝基. 解决 Windows 10 端口被 Hyper-V 随机保留（占用）的问题. 知乎, 2022-03-01 ↩感谢地心引力. 【Windows】电脑端口明明没有进程占用但显示端口被占用（动态端口）. CSDN, 2024-10-25 ↩安浩阳. 端口未被占用，但是却提示端口无法使用. 博客园, 2023-07-24 ↩scooley (microsoft). Windows NAT (WinNAT) – Capabilities and limitations. Microsoft Community Hub, 2016-5-25 ↩","categories":["SystemBug"],"tags":["Windows","port","dynamicport"]},{"title":"公告(说明)","url":"/2025/05/09/announcement/","content":"本站仍处于建设过程中~\n\n不过其实对于主题的DIY基本已经结束了~所以接下来可能会偶尔发些文章吧~\n\n因为博主能力有限，所以如果有任何建议或意见，还请多多指教~🥰\n小站引用了许多来自网络的图片，能力有限，无法全部找出原作者orz😭如需注明作者请联系博主,侵删🫶    \n","categories":["announcement"],"tags":["announcement"]},{"title":"leetcode1422题解 —— 一次遍历的在线算法","url":"/2025/09/14/leetcode1422/","content":"Problem\nProblem: 1422. 分割字符串的最大得分\n给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。\n「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。\n示例 1：\n输入：s = \"011101\"输出：5 解释：将字符串 s 划分为两个非空子字符串的可行方案有：左子字符串 = \"0\" 且 右子字符串 = \"11101\"，得分 = 1 + 4 = 5 左子字符串 = \"01\" 且 右子字符串 = \"1101\"，得分 = 1 + 3 = 4 左子字符串 = \"011\" 且 右子字符串 = \"101\"，得分 = 1 + 2 = 3 左子字符串 = \"0111\" 且 右子字符串 = \"01\"，得分 = 1 + 1 = 2 左子字符串 = \"01110\" 且 右子字符串 = \"1\"，得分 = 2 + 1 = 3\n\n示例 2：\n输入：s = \"00111\"输出：5解释：当 左子字符串 = \"00\" 且 右子字符串 = \"111\" 时，我们得到最大得分 = 2 + 3 = 5\n\n示例 3：\n输入：s = \"1111\"输出：3\n\n提示：\n\n2 &lt;= s.length &lt;= 500\n字符串 s 仅由字符 '0' 和 '1' 组成。\n\n\n核心思想单次遍历的在线贪心算法，同时解得分割线位置与最大得分。\n思路首先注意到，一个字符对于得分的贡献，完全取决于它位于分隔线的左侧还是右侧。于是我们可以发现：对于一个前缀子串, 其内部的最优分割方案不会受到及之后字符的影响。这意味着问题具备最优子结构，我们可以先尝试求解子问题的最优解然后转移得到最优解。设想一个子问题，我们已经得到了它的最优解(最大得分和分割线位置)。现增添一个新的字符，构成一个新问题, 那么这个新问题的最优解有两种来源:\n\n最优分割点在原串范围内: 由于新字符添加之后，所有旧的分割方案得分都会同步变化，因此旧范围内最优分割点位置不变，只需更新得分即可。\n最优分割点就是新增的位置：即和之间, 这是一个全新的候选解。\n\n那么，新问题的最大得分就是上述两种情况中的较大者。即只需要比较原最优分割位置与新位置的得分，取最大值，即可完成状态转移。与此同时，我们可以通过维护原最优分割线到新分割线之间0和1的数量，来快速比较两个得分，并完成切换分割点时得分的更新。所以每一步，我们只需要贪心地比较新旧位置的得分并完成更新即可。\n解题过程设字符串为，长度为n。定义下标范围为的子问题，其状态为，其中：\n\n: 当前子串的最大得分\n: 当前子串的一个最优分割点位置; 表示分割线位于到之间\n: 当前子问题分割点右侧0的个数\n: 当前子问题分割点右侧1的个数\n\n初始状态(base case):\n\n\n\n状态转移:从转移到:\n\n\n\n\n具体步骤可分解为:\n\n初始化: , 左侧为0则初始1分。\n遍历字符串中剩下的字符, 索引为 (在的时候旧位置与新位置重合，不破坏逻辑)\n每次先判断，若满足则更新, +=-, 同时清空,  。\n再判断若新字符为0，则++, 否则++并且++。\n\n\n\nCodeclass Solution {public:    int maxScore(string s) {        if(s.size()&lt;2) throw exception();        int r0 = 0;//分割点右边的0的个数        int r1 = 0;//分割点右边的1的个数        int p = 1; //分割线在index几的左边        int score = (s[0]=='0');        for(int i=1; i&lt;s.size(); ++i){            if(r0 &gt; r1){//更新分割点                p = i;                score += r0 - r1;                r0 = r1 = 0;            }            if(s.at(i) == '0'){                ++r0;            }            else{                ++r1;                ++score;            }        }        return score;    }};\n复杂度\n时间复杂度: \n空间复杂度: \n\n\n虽然这只是一道简单题，但追求极致效率的过程还是蛮有趣的。在LeetCode上看到了很多题解，但是似乎没有人提到17号的这种方法，并且17号自认这个方法简单易懂效率高，遂写了份题解，分享一下~因为17号是算法小白，写得不好的地方还请大佬们轻喷orz\n","categories":["Algorithm"],"tags":["leetcode","algorithm","c++","Greedy"]},{"title":"欢迎来到AIGC的魔法世界","url":"/2025/09/02/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0AIGC%E7%9A%84%E9%AD%94%E6%B3%95%E4%B8%96%E7%95%8C/","content":"参考在线课程https://modelscope.cn/learn/1582?pid=1577 [1]\n特别鸣谢: 阿里魔搭ModelScope平台\n\nps: 其实网站每个视频最后面都有相应的摘要\n\n本文旨在对课程核心内容进行记录与提炼，并融入了一些个人的理解和思考。文中若有任何疏漏或理解不当之处，敬请各位读者不吝指正，共同交流探讨(^_−)☆\n\n鉴于文本生成技术已广为人知，本文将重点聚焦于当前发展迅速且形式新颖的非文本内容生成，主要涵盖图像、音频及视频生成三大领域。\n\n侵删\n原理生成模型的演化历程生成模型的本质是什么？\n生成模型的本质，在于将一个服从简单随机分布(如高斯分布)的噪声与一个引导条件作为输入，通过模型复杂的非线性映射，将其转化为一个服从**目标数据真实分布(复杂随机分布)**的输出，这些输出最终表现为我们所见的图像、音频或视频等形式。\n\n随机噪声：\n\n它是生成多样性的来源。对于一个确定的模型，如果仅仅输入固定的引导条件(如提示词)， 理论上其输出应该是恒定的，因为模型本身是确定性的张量运算(就算是dropout层，也只是在训练的时候其作用，不会影响测试时的确定性)。然而在实践中，即使用户输入完全相同的提示词，每次生成的结果却也各不相同。这是因为模型在每次生成时，都会引入一个用户无法直接感知的随机噪声(通常由随机种子seed控制)。这个初始噪声的微小差异，经过模型的放大和转换，最终导致了输出结果的多样性。\n\n\n引导条件：\n\n这是用户可以控制的，用于指导生成方向的输入，例如提示词、**参考图像 (如线稿) **等\n\n\n\n生成式模型vs检索系统：\n\n从概念上讲，生成式模型与检索系统存在一个有趣的类比。两者都能根据用户输入的引导条件 (如文本) 返回相关的图像。它们的核心区别在于输出空间的性质：检索系统的输出空间是离散的 (从有限的数据中选取，是空间中离散的点)， 而生成模型的输出空间是连续的。\n这种连续性正是基于一个核心理念：与现代NLP模型类似，先进的图像生成模型同样在名为 “潜在空间(Latent Space)” 的高维向量空间中运作。 无论是输入的文本提示词，还是生成过程中的图像特征，都会被编码为这个空间中的向量(Embedding)。在这个空间中，语义相近的概念在空间位置上也相互靠近。关于潜在向量空间的理解，最早可以追溯到Word2Vec的词向量，可见这篇文章的解释\n因此，生成模型可以被视为一种平滑的检索。举个例子：它不仅能够找到代表程序员和猩猩的向量区域，更能在这些区域之间进行插值，从而创造出一个在训练数据中从未出现过，但语义上融合了两者特征的全新向量，最终解码为**程序“猿”**的图像。而离散的检索系统只能输出向量数据库中已有的离散点。\n生成式模型的演变\n如果要深入学习这个领域的话，或许可以参考这个时间脉络去进行学习。毕竟论文作者很多时候都默认读者知道一些前置的模型或概念，若是不提前了解可能会在理解上遇到一些困难\n\n当前主流的模型为 扩散(Diffusion)模型 \n其基本原理可以直观地理解为：从一张纯粹的噪声图开始，多步迭代，逐步去噪，在引导条件的指引下，最终“还原”出一张清晰的图像\n因为去噪过程实际主要依赖的是对噪声的预测能力，所以训练过程与生成过程恰好相反：向真实图像逐步叠加噪声，让模型在每一步都学习如何预测并移除被添加的噪声\n\n\n\n实践如果手上缺少算力的话可以在魔搭社区的AIGC专区玩玩 https://modelscope.cn/aigc/home\n如果有算力并且比较爱折腾的话，可以考虑使用魔搭团队开源的DiffSynth-Studio引擎[2]\n模型推理文生图文生图是最基本的生图模式，也是应用最简单，普及最广泛的一种生成模式。\n只需要用户输入一段文本形式的提示词，模型就能够生成一张相关的图像。\n提示词写作技巧前面我们已经提到，用户输入的提示实际上是对模型的一种引导条件，所以很多时候我们需要通过提示词对图像生成的内容进行引导，提示词的质量直接或间接地决定了生成图像的质量。容易理解，为了更好地指导模型，我们可能需要一些摄影的技巧；可能需要一些构图的知识   不过这大抵上属于是锦上添花，即便不懂摄影或构图，只要有审美细胞，都能进行调整\n关于写作提示词的具体技巧(范式)有\n\n提示词反推 —— 已经有了一张图，可以在这张图的基础上反推出提示词\n提示词润色 —— 更精细的描述\n负向提示词 —— 不要什么\n翻译\n因为有些图像模型，并不支持中文输入，但实际上翻译这一步有些时候可以省去。虽然很多时候使用英文提示词往往比使用中文提示词表现更好，但是我非常认可一个观点——概念优于语言。与其纠结prompt的语言，不如思考如何对AI描述清楚你的需求 [3]\n\n\n\n但事实上，我们可以让大语言模型来生成提示词，然后再自行调整\n可以参考的工具有很多[4]：\n\nLearning Prompt: 老是全权依赖工具也不是回事，可以在这里学些提示词设计经验\n\nPromptPort: 有很多现成的Prompt模版可以参考交流\n\nFlowGPT已经转型应用商店了，不太好搞。但是PromptPort体验还不错，提示词模版涉及各个领域，而且基本都有中英两版，可以阅读中文版快速理解然后复制英文版使用\n\n\n魔咒百科词典：魔法导论工具, 简单易用的AI绘画tag生成器\n\n在下第一次接触AI绘画的时候就听到有人喜欢使用“魔法导论”这样的说法来指代这个技术，这个比喻实在是有趣又贴切，因为基本的文生图AI绘画的的确确给人一种魔法的感觉，尤其是普通人第一次接触。只需要念出一连串咒语(关键词提示词)，再经由神秘的不可知域（模型黑箱）赐福，就能够创造出令人惊叹的“无上奇迹”（让一个普通人在极短的时间内创造出精密的图像）。同时它也似魔法一般，时而成功时而失败，不可预测。\n而这份“魔咒百科词典”，就是在这个魔法语境下的 提示词 模版啦。只是AI绘画的提示词往往都是关键词的形式存在的，所以正巧就变成了魔咒词典。客观地说，我们使用什么样风格的提示词其实主要取决于模型使用了什么样的文本编码器，训练的时候使用了什么样的文本描述风格。虽然早期的风格都是偏咒语形式的，但现在主流模型已经开始进化到可以支持偏向自然语言的提示词\n\n\n\n可控生成技术除了提示词这种引导形式外，还有很多其他形式的引导条件，如图所示\n\n可控生成技术为生成过程提供了远超文本提示词的、精细化的空间和结构控制，在实践中已得到广泛应用，其中非常具有代表性的框架就是ControlNet [5]\nControlNet及其衍生技术，允许用户输入一张控制图(如线稿、深度图、人体姿态骨骼图等)，在保持原图结构、姿态或构图的基础上，由扩散模型进行内容的重绘和填充。\n不难想象，这是在生成领域至关重要的一项技术。因为人类多数时候难以仅用自然语言把需求完美地进行传递。在这项技术出现前，仅靠提示词进行图像生成，就像是在开盲盒，充满了随机性。\n例如在ComfyUI这类基于节点的工作流编排工具中，上述可控生成技术就是核心组成部分。一个节点的输出（如姿态检测结果）可以作为下一个生成节点的控制输入，从而实现复杂的多步生成任务。\nps: 从某种意义上来讲LoRA或许也算得上是一种控制，只不过是属于风格、角色或概念层面的控制，而非空间结构控制。\n图像融合技术\n试试融合一个篮球和一只鸡会怎么样(x\n工作流式应用搭建\n想象一下现实中画师的工作，大多数画师也不会一笔成稿，而是经历线稿到上色，人物形体到饰品等过程。让AI也像人类一样每次专注于一个任务可以取得更好的效果。\n模型训练LoRA全称Low Rank Adaptation\n一种在预训练的图像生成模型训练完成后，低成本拓展生成能力的技术[6][7]\n\n左侧蓝色矩阵为预训练模型原先训练好的参数矩阵，这个矩阵相对来说较为庞大，如果直接进行微调，将会导致需要修改的参数量很大，训练量非常大。于是我们可以增加两个小矩阵，即图中右侧橘黄色的两个小矩阵，它们是分别是一个横长条的矩阵和一个竖长条的矩阵。假设原矩阵大小为 （ 同理）, 那么这两个小矩阵就是 , ， 于是两个小矩阵可以相乘消去r，得到一个和预训练参数矩阵维度完全一致的  的矩阵, 在进行预测的时候只需要将 作为新的模型权重参数，就可以实现对预训练参数的调整啦~\n\n\nps: 在实际应用场景中，往往还会给增量矩阵先乘上一个缩放因子​, 从而控制LoRA的力道。\n从这个公式可以看出，同时使用多个LoRA是可行的，只需要加上多项即可\n\n因为r要远小于d，所以两个小矩阵的参数量 就要比 少上很多，训练时要调整的参数量也少不少，故而使得训练成本大大降低。\n图中B=0是为了保证在训练开始的时候，能够沿用原模型的能力, 因为训练开始的时候，BA为零矩阵，加到上不会发生任何事。\n但是注意，此时A绝不能为0！\n\n试想一下A和B同时为0会发生什么，梯度会彻底消失！简单想象一下，有一个表达式 ​,  如果 为0，那么对求导的时候，导数为，那么只要不为0，就有梯度，就有可能可以训练变化；但如果此时为0，则梯度为0，这个参数完全不参与最后的预测，也自然不会被训练到。反而反之，因为地位和地位相同，若=0，不为0，则对求导仍可训练。\n\nLoRA的普适性LoRA作为一种参数高效微调 Parameter-Efficient Fine-Tuning, PEFT), 其核心是“低秩适应”这一数学思想，因此它的应用范围远不止图像生成领域。基于对上述原理的观察，在下认为，任何模型，只要其包含权重矩阵，都可以利用LoRA进行微调，甚至可以有选择地对部分权重矩阵进行微调。ps: 有文章明确提到了对Transformer使用LoRA[8]。\n\n前提：模型在微调过程中，参数的改变量是**低秩（Low-Rank）**的。因此，无需更新整个庞大的原始权重矩阵 W_0，只需学习一个低秩的增量矩阵\n\n使用LoRA即便LoRA大大降低了成本，由于模型的参数量很大，使用个人消费级显卡仍然可能很难训练。o(╥﹏╥)o\n然天无绝人之路，我们还有魔搭社区的LoRA训练功能可以免费使用！\n而且阿里的工程师大佬说，他们是打算长期让这个功能免费的，本身便没有打算盈利，而是更多地希望推动技术的发展。(✧∇✧)\n其实就算不是自行训练LoRA，使用社区里别的大佬训好的LoRA试玩一下也是很有意思的。下面这是我使用社区中miratsu style LoRA模型，参考相关提示词简单生成的图像 —— 无恶意  ^(*￣(oo)￣)^ \n\n\n训练LoRA为了训练LoRA我们需要：\n\n原始图片\n描述该图片的文本，即提示词\n\n大部分情况下，我们只有图片但没有提示词，所以需要进行图片打标\n\nAI打标：效果还是不错的；有针对打标任务特化过的模型——Florence2 / JoyCaption Beta-1\n手动打标: AI打标结果无法覆盖主体部分细节或者存在偏差，可以手动修改\n\n推荐模型图像生成工具\n\n魔搭 AIGC 图像生成专区：https://modelscope.cn/aigc/imageGeneration?tab=advanced\n开源项目 DiffSynth-Studio：https://github.com/modelscope/DiffSynth-Studio/tree/main/examples/flux\n\n视频生成工具\n\n魔搭 AIGC 视频生成专区：https://modelscope.cn/aigc/videoGeneration\n开源项目 DiffSynth-Studio：https://github.com/modelscope/DiffSynth-Studio/tree/main/examples/wanvideo\n\n音频生成工具\n\nCosyVoice：https://www.modelscope.cn/studios/iic/CosyVoice2-0.5B\nACE-Step：https://modelscope.cn/studios/ACE-Step/ACE-Step\n\nAPI服务\n\n百炼：https://bailian.console.aliyun.com/\n\n免费云计算资源（A10，24G显存暂时无法支持大模型推理和训练）魔搭 Notebook：https://modelscope.cn/my/mynotebook\n\n推荐技术路线针对于课程中提到的如何搓一个AI互动小游戏的推荐技术路线：\n\n训练图像生成模型的 LoRA（使用魔搭社区在线训练）\n\n编写脚本、分镜描述（手动编写或使用 LLM 生成）\n\n批量生成图像（使用魔搭 Notebook 调用 API）\n\n将部分图像转为视频（使用魔搭在线生成，或使用其他工具）\n\n生成配音（使用 CosyVoice 和 ACE-Step）\n\n整合资源\n\n\n前沿视频生成模型魔搭 AIGC 视频生成专区：https://modelscope.cn/aigc/videoGeneration\n音频生成模型ACE-Step模型\nCosyVoice\t\n多模态统一的模型架构\n虽然这种能够同时处理多个模态的“万能模型”听起来很美好，但事实上现阶段它就像是……啥都能干，但啥都不精 —— 博而不精。即模型虽然具备多种能力，但在任一单项任务上的表现，通常难以超越为该任务专门优化的顶尖模型。\n但是学术界和工业界仍然在乐此不疲地研究，仍然值得期待\n展望对齐训练与伦理道德\n因为AI的能力是从数据集上学习得来的，而数据集又来自于人类，这意味着AI不可避免地会学习到一些属于人类的偏好甚至偏见，导致其输出内容可能带有某些特定色彩。\n\nAI始终是服务于人类的工具\n其善恶之分\n依赖于执掌者之心\n\n额外课程图像、音频、视频、html实践案例Qwen-Image文生图、微调、编辑原理与实践\n魔搭社区小编 . AIGC多模态生成：从实践到原理（附：从0手搓一个AI互动剧情小游戏）. ModelScope, 2025 ↩ModelScope team. DiffSynth-Studio. GitHub, 2025 ↩. 探讨：中文提示词和英文提示词的效果区别. LINUX DO, 2025 ↩知白守黑. Prompt资源精选|你想要的AI提示词都在这里了. 知乎, 2025 ↩Rocky Ding. 深入浅出完整解析ControlNet核心基础知识. 知乎, 2025 ↩Hu, Edward J., et al. LoRA: Low-Rank Adaptation of Large Language Models. arXiv preprint arXiv:2106.09685, 2021 ↩大师兄. LoRA（Low-Rank Adaptation）详解. 知乎, 2023 ↩Dreamweaver. 大模型的领域适配 —— Parameter-Efficient Fine-Tuning (PEFT). 知乎，2023 ↩","categories":["AI","AIGC"],"tags":["AI","AIGC","Course Note","practice"]},{"title":"图片格式解析","url":"/2025/09/17/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/","content":"简记一些常见图片格式的解析，属于随笔笔记性质，并非详解。\n目标是作为一个用户对最常见的几种图片格式建立基本的认知模型，同时理解如何从图像数据流中提取出图像的分辨率，即宽高属性。\nPNG主要参考2025年6月25日发布的第三版PNG规范[1]\n\n关于PNG存储格式，具体官方说明请参考官方说明的第五节Datastream structure\n\nPNG图像由文件署名和数据块两种类型的结构组成。\n文件署名域其中文件署名域用于确认一个文件是否是PNG文件\n用16进制打开任意PNG文件, 会发现前八个字节总是这几个十六进制数 89 50 4E 47 0D 0A 1A 0A \n这八个字节就是PNG的文件署名。出现这个签名则表明剩下的内容包含单个PNG图像，该图像由一系列以’IHDR’开头、以’IEND’的数据块组成。\n注：根据PNG官方的说法，一张PNG图像可能由多张动画序列帧组成(类似GIF)。所以通俗的理解，出现一个PNG签名，意味着现在得到的数据是一个PNG数据。不管后面存储的是一张静态的图像，或是多张动画序列帧(感觉上像是多张图像)，它在技术上都属于单张PNG图像。因为存储方式上是完全类似的，单张静态图像是签名后面跟了几个数据块，而多张动画序列帧也是签名后面跟了几个数据块，只不过数据块的类型和数量不同罢了。\n\nps: 推荐使用VScode的Hex Editer插件，可以方便地使用十六进制查看文件，同时也能显示解码后的文本\n\n\n\n\n\n如图所示，文件署名域对应一张PNG图像的前八个字节，而且里面还偷藏了一个”PNG”\n数据块除了署名，剩下的应该就都是数据块了。很多的个数据块堆叠用来存储数据。其结构如下：\n其实非常简单，个人认为只需要建立上面那个 四个Field 的认知模型即可，每个Field分别代表(按顺序排布)\n\nlength: 四字节无符号整数，用于指定 实际数据CHUNK DATA 的长度 —— 所以长度为0的时候CHUNK DATA域等效于不存在\nchunk type: 四字节，每个字节可以理解为一个ASCII码，Each byte of a chunk type is restricted to the hexadecimal values 41 to 5A and 61 to 7A，熟悉的话其实会发现，这其实就是约束了每个字节对应的ASCII字符就是’A’-‘Z’ 或 ‘a’-‘z’, 也就是说是直接人类可读的英文字母编码\nchunk data：实际的数据内容。长度由length域约束，可为0\nCRC： 四字节， 仅根据CHUNK TYPE和CHUNK DATA计算出来的值，应该是校验码，这里不用太在意其中细节。\n\n至此，数据块的基本结构就已经结束了。整个PNG存储的模型也就出来了，剩下的就只需要在用得到的时候补全对于不同类型数据块结构的认知即可。\n就是说，接下来去翻官网的#11. Chunk specifications 就可以啦~， 这里列出几种常用的\n必须存在的数据块类型有些类型的数据块必须存在于一张PNG图像中，称为Critical Chunk， 以下几种都是\n开头与结尾 IHDR-IEND类型一个是IHDR，一个是IEND， 没必要记16进制码，直接记字母就行。\nIHDR是非常特殊的块，它和IEND一起框定了一串数据的范围。应该可以理解为，一段有效的数据，比如一帧，它会是很多数据块，解析的时候遇到IHDR就知道这段数据开始了，遇到IEND意味着这段数据结束了。 甚至还有人发现可以在IEND后面藏数据而不影响图像显示[2]\t\n\n出现在签名章节: This signature indicates that the remainder of the datastream contains a single PNG image, consisting of a series of chunks beginning with an IHDR chunk and ending with an IEND chunk.\n\nIHDR Image headerIEND没必要讲，就是一个结束标志。但是IHDR类型对应的数据块还存储了一些有用的信息。(必须是PNG datastream的第一个chunk)\n注：这里的总长度是固定的13bytes\n\n\n\n\n\n\n\n\nWidth\n4 bytes\n\n\nHeight\n4 bytes\n\n\nBit depth\n1 byte\n\n\nColor type\n1 byte\n\n\nCompression method\n1 byte\n\n\nFilter method\n1 byte\n\n\nInterlace method\n1 byte\n\n\n一般用户感觉只需要关注前4个属性即可，分别代表图像的宽、图像的高、图像位深、颜色类型\n宽高以像素为单位。这里的位深指的是每个颜色通道的位深，而不是整个像素的位深，即记录的是每个颜色通道使用多少比特进行编码。\n颜色类型：\n\n虽然没有找到明确说明这些属性是顺序排布的，不过基于“协议本身是稳定的”的解释，可以找一张PNG图像拆开来验证一样——结论：至少前四个属性是按顺序存储的。\n\n这里宽是0x500，对应十进制1280，长为0x8E3，对应十进制2275，这正好就是在下这张测试图像分辨率中的宽高，通过测试。\n08对应颜色位深8，02对应真彩色图像，RGB三色通道各使用8位编码，所以每个像素使用位编码，而在下通过图像属性观测到的数据完美符合预期，通过测试。\n\n\n注: 数据大端对齐，即高字节对应低地址\n\nPLTEPalette，调色盘。\n含1-256个entries，每个entry三个字节，每个字节分别对应红绿蓝。\n感觉主要是用于压缩等用途的元信息，不用太在意。\nIDATImage Data， 图像真实的数据\n注：不是将每个像素的RGB存储的原始数据，而是压缩算法的输出结果\n\n必须的数据块类型就上述四种，其它感兴趣可以去文档中了解。\nJPEG特别注意，JPEG和PNG不同，并非一个单一独立的规范，而存在很多不同的标准——不同的文件格式。这里参考的是T.81标准[3], 又称ISO/IEC 10918-1 标准,  算是JPEG压缩技术最权威最官方的一个技术标准了，应该能够解释绝大部分JPEG文件的格式，如JFIF和Exif。文献很长，这里只关注JPEG的数据结构，基本可以从31页的Compressed data formats章节开始看。这里我不打算做很详细地解读，主要目标是解析到“能够得到图像的尺寸”的程度(因为真实的数据反正也要过压缩算法，费劲搞清楚了感觉一般也用不到)。\n宏观设计从最高层次看，JPEG文件有点像之前的PNG，但不完全一样。JPEG文件的数据流由一系列 “参数、标记段、数据段”(参数并不作为独立的实体存在，主要关注maker segment和data segment)的有序集合构成。\n\nStructurally, the compressed data formats consist of an ordered collection of parameters, markers, and entropy-coded datasegments. Parameters and markers in turn are often organized into marker segments. Because all of these constituent partsare represented with byte-aligned codes, each compressed data format consists of an ordered sequence of 8-bit bytes. Foreach byte, a most significant bit (MSB) and a least significant bit (LSB) are defined\n\n可以想象我们是一个流式的数据解析器，我们顺序地读入JPEG数据，会读到一个个数据段，在真实数据段之前会读到标记段(Marker Segement)，这些标记就告诉了我们接下来会遇到什么数据，有点像PNG数据块的数据类型字段。而我们可以利用这些像“路标”一样的标记，快速跳过不需要的信息。\n整体上来看，JPEG文件的数据流就是一连串的标记段和穿插的几个数据段\n所以对我们来说现在最重要的就是如何辨识标记(Marker)\n标记Marker总结，找到字节0xFF，并且后面不是0x00, 就找到了Marker，0xFF后面跟的字节就决定了类型。\nMarker的格式长两个字节\n\n第一个字节：一定是 0xFF。 这个特别的值应该就是专门保留出来标识Marker的\n\n第二个字节：\n\n特殊情况\n\n不能是0x00： 为了防止在数据段出现0xFF被误认为Marker，所以数据中的0xFF后面都会跟上0x00， 表明这是数据。\n如果是0xFF:  被称为填充字节(fill bytes), 并不代表Marker的类型，仅做填充。可能是出于数据对齐的考量而设计，总之解析到0xFF的话，就继续往下看一位\n\n\n正常情况，第二个字节标识了Marker的类型，标识了接下来的数据是什么类型的数据，具体匹配关系可以参见下表\n\n\n\n\n\n\n\n特别说明：文档中提到的，Marker中存储的两字节长度参数，特指该Marker段的长度(不包含开头的‘两’个字节，但是包含记录长度的两个字节)，并不代表后面可能跟着的数据段的长度。这个参数用于快速跳过该Marker段达到下一个Marker段。\n具体数据构造\n让我们结合例子逐步剖析。这里使用onlinehexeditor作为十六进制查看器，因为它还能提供对jpeg结构的部分信息的解析与提取，有助于辅助我们构建认知模型。\n注：建议将Marker表钉在屏幕的某个位置，方便确认Marker类型。\n可以看到JPEG其实是一个多层级结构，把Frame视为主体，则两侧分别有SOI和EOI，这里我上传了一张jpeg图像作为示例\n\n\n查表不难发现，开头的数据和结尾的数据恰恰就是SOI和EOI的Marker。然后这两个Maker没有长度，因为仅作标识作用，无内部信息需要存储。\n然后我们进入真实的数据帧，重点要找的是帧头Frame Header, 但沿途的景色我们也顺便解析一下。\n\nAPP 是为应用程序预留的，可能会有很多，在这里会写入些应用程序想要写入的元数据。可能是用于进行控制——比如旋转，有可能就只是记录一些信息。比如这里看右侧转译结果，可以隐约看到JFIF的字眼，这说明该JPEG图像大概率是基于JFIF标准的。至于comment，则如其名。\nDQT代表定义量化表Define Quantization Table，这跟JPEG的压缩算法直接相关。大致理解的话，应该是在压缩过程中，具体可参考文档中的DCT算法，对于处理后得到的8 × 8 DCT coefficient array，去除以量化表中的64个值。这里注意到DQT段的长度并非0x0041(多出来的第一个字节是量化精度)而是0x0084, 应该是因为这里存了两个量化表，0x0082的长度，再算上长度数据本身的两个字节，就计算得到了0x0084.\n再往后就到了我们能够解析出图像尺寸的最重要的Frame header了！(不知道为什么文档35页对应部分只特别提了所有非差分类型的SOF，但私以为Frame Header的结构应该都是一样的，即图中所示SOF, 是一种一般表示)\n\n仍然是Marker Segment，但是是SOF类的。所以关键在于遍历到SOF的Marker然后停下。\n第一个参数Lf其实就是这个Segment的长度，和之前都一样，占两个字节。第二个参数P表示样本精度，即每个采样点sample需要多少位来存储，即每个color的位深。\n噔噔噔，然后终于，我们遇到了Y和X参数，看看它们的官方解释\n\nY: Number of lines – Specifies the maximum number of lines in the source image. This shall be equal to the number of lines in the component with the maximum number of vertical samples (see A.1.1). Value 0 indicates that the number of lines shall be defined by the DNL marker and parameters at the end of the first scan (see B.2.5)\nX: Number of samples per line – Specifies the maximum number of samples per line in the source image. This shall be equal to the number of samples per line in the component with the maximum number of horizontal samples (see A.1.1)\n\n一个是行数，一个是每行的采样点数量，这很显然就是我们一直在寻觅的宽高了。浅看一下这几个参数的位宽。\n\n让我们结合刚才那个例子来观察一下，\n\n可以看到P是8，单色为8，三色乘3便是24，而高宽分别为十六机制0x0438, 十进制数1080。这恰好符合文件属性。\n\n注：这里可能会有一点让人感到困惑的地方。P是8，表示这里的sample是一个color sample，而X是1080，又说明一行的元素个数和一行的像素个数相同。其实这不矛盾，想象多个矩阵阵列即可理解，不同颜色的矩阵可以独立存储(即不是[R1, G1, B1], [R2, G2, B2], [R3, G3, B3] … 这样存的)。\n刚才那张图高宽相同，可能有些迷惑，这里再换个例子看一遍，这是另一张位深24，分辨率4096x2160的JPEG图像。\n\n可以看到，高0x0870, 即十进制2160，宽0x1000，即十进制4096, 完美符合预期，顺序也可以得到映证。\n为了直观地感受到这张图是扁的，而非长的，这里附上分辨率4096x2160的样例图:\n\n\n眼见的话其实会发现刚才两个案例在ffc0的Marker后面都出现了ffc4， 这个对应的是Marker DHT， 即Define Huffman table(s), 哈夫曼表。这里涉及到压缩算法，不展开讲——因为它似乎有很多版本, 至少除了Huffman coding还有arithmetic coding。\t\n不管怎么说，到底我们就能得到绝大多数JEPG图像尺寸了(基于T.81标准的)。\nGet Image Size基于以上观察，这里给出获取PNG图像和大部分JPEG图像(包括JFIF和EXIF)宽高的js代码。仅供参考:\n/** * @file imageSize.js * A image dimension parser. * Supports PNG and JPEG formats. *//** * A function to get dimensions of PNG and JPEG images from a Buffer. * @param {Buffer} buffer The image data buffer. * @returns {{width: number, height: number, type: 'png' | 'jpeg'} | null} */function imageSize(buffer) {  try {    //PNG    const pngResult = parsePNG(buffer);    if (pngResult) {      return pngResult;    }    //JPEG    const jpegResult = parseJPEG(buffer);    if(jpegResult){      return jpegResult;    }    console.error('Unsupported image format')    return null;   } catch (e) {    console.error(e);    return null;  }}// --- Constants for PNG Parsing ---// reference: https://www.w3.org/TR/png-3/#5DataRep// All PNG files start with this 8-byte signature.const PNG_SIGNATURE = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);// The IHDR chunk type identifier in ASCII.const IHDR_CHUNK_TYPE = Buffer.from('IHDR');// The IHDR chunk's data section must be 13 bytes long.const EXPECTED_IHDR_LENGTH = 13;/** * Parses a Buffer to extract dimensions of a PNG image. * @param {Buffer} buffer The buffer containing the image data. * @returns {{width: number, height: number, type: 'png'} | null} Dimensions object or null if not a valid PNG with IHDR chunk. */function parsePNG(buffer) {  try {    // A valid PNG with dimensions requires at least 33 bytes for signature and IHDR info.    // 8 (signature) + 4 (length) + 4 (type) + 13 + 4(CRC) = 33 bytes    if (buffer.length &lt; 33) {      return null;    }    // Verify the PNG file signature.    if (!PNG_SIGNATURE.equals(buffer.subarray(0, 8))) {      return null;    }    // --- IHDR Chunk Verification  ---    // length must be 13. readUInt32BE reads a 4-byte, Big-Endian integer.    const ihdrLength = buffer.readUInt32BE(8);    if (ihdrLength !== EXPECTED_IHDR_LENGTH) {      return null;    }    // type must be \"IHDR\".    const chunkType = buffer.subarray(12, 16);    if (!IHDR_CHUNK_TYPE.equals(chunkType)) {      return null;    }    // --- extract the dimensions ---    // width: 4 bytes    const width = buffer.readUInt32BE(16);    // height: 4 bytes    const height = buffer.readUInt32BE(20);    return { width, height, type: 'png' };  } catch (e) {    console.error(e);    return null;  }}// --- Constants for JPEG Parsing ---// reference: ITU T.81, Annex B  https://www.w3.org/Graphics/JPEG/itu-t81.pdf// Start of Image markerconst JPG_SOI = 0xFFD8;// End of Image markerconst JPG_EOI = 0xFFD9;// Start of Frame markers //non-differential, Huffman codingconst JPG_SOF0  = 0xFFC0; // Baseline DCTconst JPG_SOF1  = 0xFFC1; // Extended sequential DCTconst JPG_SOF2  = 0xFFC2; // Progressive DCTconst JPG_SOF3  = 0xFFC3; // Lossless (sequential)//differential, Huffman codingconst JPG_SOF5  = 0xFFC5; // sequential DCTconst JPG_SOF6  = 0xFFC6; // progressive DCTconst JPG_SOF7  = 0xFFC7; // lossless (sequential)//non-differential, arithmetic codingconst JPG_SOF9  = 0xFFC9; // Extended sequential DCTconst JPG_SOF10 = 0xFFCA; // Progressive DCTconst JPG_SOF11 = 0xFFCB; // Lossless (sequential)//differential, arithmetic codingconst JPG_SOF13 = 0xFFCD; // sequential DCTconst JPG_SOF14 = 0xFFCE; // progressive DCTconst JPG_SOF15 = 0xFFCF; // lossless (sequential)const SOF_MARKERS = [  JPG_SOF0, JPG_SOF1, JPG_SOF2, JPG_SOF3,  JPG_SOF5, JPG_SOF6, JPG_SOF7,  JPG_SOF9, JPG_SOF10, JPG_SOF11,  JPG_SOF13, JPG_SOF14, JPG_SOF15]/** * Parses a Buffer to extract dimensions of a JPEG image. * @param {Buffer} buffer The buffer containing the image data. * @returns {{width: number, height: number, type: 'jpeg'} | null} */function parseJPEG(buffer){  try{    //Start with SOI    if(buffer.readUInt16BE(0) !== JPG_SOI){      return null;    }    let offset = 2;    let marker = buffer.readUInt16BE(offset);    while(!SOF_MARKERS.includes(marker)){      //if not the SOF marker, skip to the next marker; note: RST_m will not occur before frame header, so we do not check for      length = buffer.readUInt16BE(offset+2);      offset += length + 2;      marker = buffer.readUInt16BE(offset);    }    //For frameheader: 2 for marker, 2 for length, 1 for precision, 2 for height, 2 for width    return { height: buffer.readUInt16BE(offset+5), width: buffer.readUInt16BE(offset+7), type: 'jpeg' };  }catch(e){    console.error(e);    return null;  }}module.exports = {  imageSize,  parsePNG,   parseJPEG,};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nW3C. Portable Network Graphics (PNG) Specification (Third Edition). W3C, 2025-06-25 ↩maxiongying. PNG文件格式详解 . 博客园, 2018-08-25 ↩CCITT (The International Telegraph and Telephone Consultative Committee) / ITU (International Telecommunication Union). Recommendation T.81: Information Technology - Digital Compression and Coding of Continuous-tone Still Images - Requirements and Guidelines. ITU (International Telecommunication Union), 1992-9-18 ↩","categories":["Image","protocol"],"tags":["PNG","image","protocol","parser"]}]