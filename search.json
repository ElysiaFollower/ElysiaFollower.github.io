[{"title":"MCP","url":"/2025/05/08/MCP/","content":"introduction由claude的母公司Anthropic于2024年11月25日推出，全称模型上下文协议(Model Context Protocol)\n\n这是一个开放标准, 在该网站可以看到官方文档 https://modelcontextprotocol.io/\n\n中文文档：https://mcp-docs.cn/introduction\n\n\n旨在将人工智能应用与不同工具和数据源进行连接\n\n提供一种标准化的路径来沟通 模型 与 工具\n属于中间协议层， 就像USB-C转接器一样，统一外部server接入host， 如下图所示， 通过MCP client作为转接器，不同的Server最终以统一的接口形式暴露给host，让模型得知。\n\n\n\n\nMCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools.\n\n\n\n本质上是在模型和外部工具间添加一个 中介程序， 对接口进行封装\n\n原先的外部工具套上一层壳(规范接口)就成了一个个server\n中介程序中由client 和 server 打交道\n通信基于MCP协议\n\n\n而容纳client的中介程序，就是MCP Host —— 例如vscode的cline插件\n\n具体架构见图 架构\n现实意义能够帮助我们在抽象的顶层设计设计agent或Workflow —— 相当于将模型与工具封装隔离，设计者不需要过多考虑交互的细节与融合。而现在的LLMs经常需要同外部数据或者工具进行融合，以此来增强自己的能力\n举个例子，假如没有MCP，那么不同如 Claude Desktop、IDE 或 AI 工具等AI应用，想要增加外部工具的调用，则需要彼此按照自己的村规对每个不同的工具做适配(比如function calling)\n而引入MCP协议作为中间层之后，一切变得井然有序, 如右图(目前的MCPserver数已经上万，如果没有中间层，这是不可想象的)\n在此之后，甚至可能可以基于MCP协议对模型进行专门的训练，使之对工具使用的接口更加熟悉，调用更加稳定。(因为本质上要求模型按规定格式输出)\n\n一般架构\nMCP Hosts: 如 Claude Desktop、IDE 或 AI 工具，希望通过 MCP 访问数据的程序\n\nMCP Clients: 维护与服务器一对一连接的协议客户端\n\nMCP Servers: 轻量级程序，通过标准的 Model Context Protocol 提供特定能力\n\n本地数据源: MCP 服务器可安全访问的计算机文件、数据库和服务\n\n远程服务: MCP 服务器可连接的互联网上的外部系统（如通过 APIs）\n\nMCP Hosts: Programs like Claude Desktop, IDEs, or AI tools that want to access data through MCP\n\nMCP Clients: Protocol clients that maintain 1:1 connections with servers\n\nMCP Servers: Lightweight programs that each expose specific capabilities through the standardized Model Context Protocol\n\nLocal Data Sources: Your computer’s files, databases, and services that MCP servers can securely access\n\nRemote Services: External systems available over the internet (e.g., through APIs) that MCP servers can connect to\n\n\n\n其中MCPserver虽然名字里带个server但它实际上完全可以是本地的一个程序，只是在逻辑关系上就像提供服务的server一样——因为本质上是外部工具的封装\n外部工具封装成MCP Server， 根据MCP协议，在传输层与MCP Client进行交互， client再将信息整合与Host交互\n\n传输层实现细节文档：https://modelcontextprotocol.io/docs/concepts/transports#standard-input%2Foutput-stdio\n有两种传输方式\n\nstdio(适用于本地进程，两者都在同一台计算机上)\n在这种模式下，server进程被client进程创建出来作为子进程，然后通过标准输入输出进行交互\nclient把消息写到server的stdin， server把response写到它的stdout\n\n\n\n\n基于HTTP的SSE传输(SSE: Server-Sent Events) \n使用 Server-Sent Events技术实现client到server的通信\nclient使用HTTP GET和HTTP POST与server进行交互\n\n\n通信的协议内容基于JSON-RPC2.0\n\n\n\n\n其实也允许自定义传输方式，但那样就偏离了统一接口的目的，因为又引入了未定义的行为\n\n核心概念\nResources\n\n它允许server暴露可以被 clients 读取并用作 LLM 交互上下文的数据和内容\n\nserver通过resources/list endpoint暴露可用资源，resource结构\n&#123;  uri: string;           // Unique identifier for the resource  name: string;          // Human-readable name  description?: string;  // Optional description  mimeType?: string;     // Optional MIME type&#125;\n\n或者\n&#123;  uriTemplate: string;   // URI template following RFC 6570  name: string;          // Human-readable name for this type  description?: string;  // Optional description  mimeType?: string;     // Optional MIME type for all matching resources&#125;\n\nclient可以通过resources/read 请求读取resources\n\n\n\n\n\nPrompts\n\n允许 servers 定义可复用的提示模板和工作流，可以被Client获取\n\nprompt结构\n&#123;  name: string;              // Unique identifier for the prompt  description?: string;      // Human-readable description  arguments?: [              // Optional list of arguments    &#123;      name: string;          // Argument identifier      description?: string;  // Argument description      required?: boolean;    // Whether argument is required    &#125;  ]&#125;\n\nclient可以通过prompts/list发现可用的prompts模版，然后嵌入必要的参数，通过prompts/get 进行使用\n\n\n\n\n\nTools\n\n使 servers 能够向 clients 暴露可执行功能\n\nTool结构\n&#123;  name: string;          // Unique identifier for the tool  description?: string;  // Human-readable description  inputSchema: &#123;         // JSON Schema for the tool&#x27;s parameters    type: &quot;object&quot;,    properties: &#123; ... &#125;  // Tool-specific parameters  &#125;,  annotations?: &#123;        // Optional hints about tool behavior    title?: string;      // Human-readable title for the tool    readOnlyHint?: boolean;    // If true, the tool does not modify its environment    destructiveHint?: boolean; // If true, the tool may perform destructive updates    idempotentHint?: boolean;  // If true, repeated calls with same args have no additional effect    openWorldHint?: boolean;   // If true, tool interacts with external entities  &#125;&#125;\n\nClients 可以通过 tools/list endpoint 列出可用的 tools\n\nClient 可以使用 tools/call endpoint 调用tool，servers 执行请求的操作并返回结果\n\n\n\n\n\nSampling\n\n它允许 servers 通过 client 请求 LLM 补全，从而实现复杂的 agentic 行为，同时保持安全性和隐私性\n\n这里产生了对LLM的请求，需要借用Host完成，而后文会提到这并不在MCP明确规定的范围内，所以未必所有的Host都支持该功能\n\n如Claude Desktop\n\nThis feature of MCP is not yet supported in the Claude Desktop client.\n\n\n\n\n\n\nRoots\n\n它定义了 servers 可以操作的边界\n告知 servers 相关 resources 及其位置信息\n明确哪些 resources 是你的 workspace 的一部分\n\n\n\n\n\n注意上述的这些核心概念，一般只有Tool部分是都会支持的，其它的具体要看client和host的实现\n\n工作过程Client 和 Server之间的通信\n\nClinet向Server发生初始化请求\nServer会告诉Client自己拥有哪些工具以及协议版本(&gt; protocol version and capabilities)\nClient向Server发送信息，确认初始化成功\n开始正常信息交流\nRequest-Response: Client或Server发生请求，另一方响应\nNotifications: 一方单方面发送消息，不要求响应\n\n\n\n当出现以下三种情况时终止\n\n使用close()干净关闭\n传输断开\n出现错误\n\nClient 和 模型之间的通信\nMCP协议主要规定的是client和server之间的通信，Client和模型之间的通信会受到host具体实现的影响，但这一部分仍然有助于我们理解一个MCP应用的工作流程\nAnthropic的官网上似乎并没有规定Client和AI模型之间的通信 —— 只是规定了client和server之间的通信\n\n\n\n以cline为例，有人通过数据抓包发现，在实际工作的时候，Cline插件并没有使用function calling技术，而是——直接把所有外部工具的详细信息直接写在了提示词中(json格式，系统提示词，”role”:”system”)，甚至还有Cline内置的工具，甚至还有详细的使用案例教学，长达上万字符。其中用户的信息也同样在这段提示词中，通过另一项json来进行指定(用户提示词，”role”: “user”)。\n所以发生的事情是这样的：\n\nHost(如Cline)， 将用户的require附加上关于MCP工具的所有使用说明提供给模型\n模型按照提示词指定的格式调用工具，如使用标签进行标记\n如果模型请求了工具调用，那么工具执行结果很可能会和原先的系统提示词、用户提示词一起发给模型，让它进行重新生成，直到没有工具调用请求。\n\n\n\n\n引自BV1sWoMYUEi9， https://zhuanlan.zhihu.com/p/29001189476\n\n\n工程实践以下是一些MCP server汇总网站\n\nhttps://smithery.ai/\nhttps://mcp.so/\nhttps://www.mcp-home.com/\nhttps://mcpmarket.com/\nhttps://mcpmarket.cn/\nhttps://mcpservers.org/\n\n使用示例找到一个心仪的MCP server(或者自己做一个)\n\n这里使用的MCP Server：https://mcp.so/server/fetch/modelcontextprotocol\n\n一般来说，他会是类似的界面，有一些说明，但最重要的是右侧红框标记的Server Config， 将其复制到MCP Host的MCP Server配置文件即可\n\n以cline作为客户端为例：\n找到一个配置选项，点击就会打开一个json文件\n\n在这个json文件复制进入从server提供者那里得到的server config即可——如果有多个的话，用逗号隔开。\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;fetch&quot;: &#123;      &quot;command&quot;: &quot;uvx&quot;,      &quot;args&quot;: [&quot;mcp-server-fetch&quot;]    &#125;  &#125;&#125;\n以类似上述json格式去定义MCPserver其中fetch为一个MCPserver的名字，运行的程序为uvx，参数为mcp-server-fetch\n\n所以可知，需要首先下载uvx程序\nMCPserver大多使用python或者node进行编写，对应启动程序一般是(在MCP server供应处复制的时候看看command是什么就知道了)\npython - uvx(uv tool run的别名)\nnode - npx\n\n\n关于uv：\n\nAn extremely fast Python package and project manager, written in Rust.\n\n\npython包管理器\n\n\n文档：https://docs.astral.sh/uv/\nmac+linux安装： curl -LsSf https://astral.sh/uv/install.sh | sh\nwindows安装： powershell -ExecutionPolicy ByPass -c &quot;irm https://astral.sh/uv/install.ps1 | iex&quot;\n\n\n关于npx, 其为node的一部分，所以已经安装过Node.js的不需要做额外安装\nuvx&#x2F;npx之外的command同理(原理是通的，都是运行命令做一些事情)\n\n\n\n在客户端配置MCPserver的时候很多时候会运行命令、进行注册，所以要保证安装成功才能正常注册。\n\n注：在客户端配置完MCPserver可能会出现以下情况\n尝试运行命令-&gt;发现对应工具没有安装-&gt;开始下载安装-&gt;安装太久，超时-&gt;配置失败\n则解决方法为，现在自己的终端运行一遍，保证下载完成，例如uvx mcp-server-fetch\n下载完成可能需要手动退出，因为对应程序可能会被运行，然后开始等待输入\n\n\n\n\n\n\n\n在网站找到提供的MCPserver时，提供方提供的json可能是上面那个示例的格式但在实际配置的时候，可能会出现多两个参数disabled和timeout分别表示是否启用该工具以及超时时间\n还有一个transportType，这也是非常重要的，有两种选择，就是先前于传输层实现细节提到的，但是网上具体的MCP Server提供的Server Config模版很多时候不自带这个选项，可以自行指定\n\nstdio\nsse\n\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;fetch&quot;: &#123;      &quot;disabled&quot;: false,      &quot;timeout&quot;: 60,      &quot;command&quot;: &quot;uvx&quot;,      &quot;args&quot;: [        &quot;mcp-server-fetch&quot;      ],      &quot;transportType&quot;: &quot;stdio&quot;    &#125;  &#125;&#125;\n\n然后就可以使用了\n\n同理，在Claude Desktop中\n找到对应的位置，打开config.json （claude_desktio_config.json）\n\n复制写入必要内容，然后重启Claude Desktop即可使用。\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;fetch&quot;: &#123;      &quot;command&quot;: &quot;uvx&quot;,      &quot;args&quot;: [        &quot;mcp-server-fetch&quot;      ],      &quot;transportType&quot;: &quot;stdio&quot;    &#125;  &#125;&#125;\n\n"},{"title":"test1","url":"/2025/05/07/test1/","content":"StartDo something here\n","categories":["start","nothing"],"tags":["test"]},{"title":"Hello World","url":"/2025/05/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["start"],"tags":["hello"]},{"title":"test3","url":"/2025/05/07/test3/","content":"","categories":["test"],"tags":["test"]},{"title":"test2","url":"/2025/05/07/test2/","content":"","categories":["test"],"tags":["test"]}]